#!/usr/bin/env python

import sys
import subprocess
import os.path
import os
import hashlib
import json
import fnmatch
import requests
import pycurl
import dulwich.porcelain as porcy
import errno

from requests_toolbelt.multipart.encoder import MultipartEncoder

# For SRR support
import httplib
import re

DEFAULT_LOG_LEVELS=['INFO', 'WARN', 'ERROR']

LOG_LEVELS = DEFAULT_LOG_LEVELS

def load_scp(filename, checksum):
  remote = get_remote()
  subprocess.check_call(['scp', '%s/%s.got' % (remote, checksum), filename])

def store_scp(filename, checksum):
  remote = get_remote()
  subprocess.check_call(['scp', filename, '%s/%s.got' % (remote, checksum)])

def store_srr(filename, checksum):
  (server_name, parent_id) = get_location_info_srr()
  local_path = filename
  target_id = ''
  remote_path = '%s' % checksum
  description = 'Got storage for %s/%s @ TBD hashtag' % (get_root(), filename)

  m = MultipartEncoder(fields={
    'parent_id' : parent_id,
    'target_id' : '',
    'description' : description,
    'file' : (checksum, open(filename, 'rb'), 'application/octet-stream')})
  response = requests.post('http://%s/srr/api/add_file' % server_name, data = m, headers = {'Content-Type' : m.content_type})

  if response.status_code != 200:
    raise SRRError("%s: %s" % (response.reason, result))
  new_id_re = re.compile(r' file_id=(\d+)\s*$')
  m = new_id_re.search(response.text)
  if m:
    return int(m.group(1))
  else:
    raise SRRError("Unexpected result from SRR: %s" % result)

def parse_path_srr(path):
  result_re = re.compile('http://(.*)/.*/(\d+)$')
  matches = result_re.match(path)
  return (matches.group(1), matches.group(2))

def get_location_info_srr():
  return parse_path_srr(get_remote())

def get_remote_path_srr(server, checksum):
  response = requests.get('http://%s/srr/api/file_metadata/md5/%s' % (server, checksum))
  return response.json()['url']

def load_srr(filename, checksum):
  (server, parent_id) = get_location_info_srr()

  if status_local(get_got_filename(filename)):
    return

  path = get_remote_path_srr(server, checksum)
  print filename
  print path

  with open(filename, 'wb') as f:
    c = pycurl.Curl()
    c.setopt(c.URL, path)
    c.setopt(c.WRITEDATA, f)
    c.perform()
    c.close()

remote_store_file = store_srr
remote_load_file = load_srr

def init_backing_store():
  global remote_store_file
  global remote_load_file
  configuration = load_configuration()
  if configuration['remote_type'] == 'srr':
    remote_load_file = load_srr
    remote_store_file = store_srr
  else:
    remote_load_file = load_scp
    remote_store_file = store_scp

def usage():
  print 'git got <command> [<args>]'
  print
  print 'The most commonly used git got commands are:'
  print '  init   Initialize the remote to be used with the repository'
  print '    <repository type> <parameters>'
  print '  get    Retrieve all remote files to the local working area'
  print '  add    Add a file to the remote repository'
  print '  status Request the status of a got tracked file'
  print '  reset  Ovewrite a gotted file with the remote copy'

root_path = ""
repo = None

def reset():
  global root_path
  root_path = ""

def get_repo():
  global repo
  if repo is None:
    repo = porcy.open_repo(get_root())
  return repo

def git_add(filename):
  repo = get_repo()
  log_debug('git_add: Adding file %s to %s' % (filename, repo))
  porcy.add(repo, filename)

def get_root():
  global root_path
  if root_path == "":
    root_path = os.getcwd()
    old_root_path = ''
    while not os.path.exists(os.path.join(root_path, '.git')) and root_path is not old_root_path:
      old_root_path = root_path
      root_path = os.path.dirname(root_path)
  return root_path

configuration = None

def file_hash(filename):
  hasher = hashlib.md5()
  with open(filename, 'rb') as infp:
    while True:
      data = infp.read(8192)
      if not data:
        break
      hasher.update(data)
  return hasher.hexdigest()

def load_configuration():
  global configuration
  if configuration is None:
    with open('.got/storage', 'r') as storagefp:
      configuration = json.load(storagefp)
  return configuration

def get_remote():
  configuration = load_configuration()
  return configuration['remote']

def get_local_got_filename(fully_qualified_filename):
  (base, filename) = os.path.split(fully_qualified_filename)
  return os.path.join(base, '.%s.got' % filename)

def get_got_filename(fully_qualified_filename):
  (root, filename) = os.path.split(fully_qualified_filename)
  return os.path.join(root, '.%s.got' % filename)

def get_real_filename(fully_qualified_filename):
  (root, filename) = os.path.split(fully_qualified_filename)
  return os.path.join(root, filename[1:-4])

def get_cb(filename):
  try:
    real_filename = get_real_filename(filename)
    log_debug('get_cb: Using %s for local file' % real_filename)
    csum = open(filename).read().rstrip()
    remote_load_file(real_filename, csum)
  except Exception as e:
    log_error('Failed to retrieve file %s' % filename, e)

def reset_cb(filename):
  try:
    log_debug('reset_cb: Reseting %s' % filename)
    got_filename = get_local_got_filename(filename)
    log_debug('reset_cb: Using %s for local got file' % got_filename)
    csum = open(got_filename).read().rstrip()
    remote_load_file(filename, csum)
  except Exception as e:
    log_error('Failed to reset %s' % filename, e)

def add_cb(filename):
  try:
    log_debug('add_cb: Adding %s' % filename)
    csum = file_hash(filename)
    remote_store_file(filename, csum)
    got_filename = get_local_got_filename(filename)
    with open(got_filename, 'w') as hash_file:
      hash_file.write('%s' % csum)
    git_add(got_filename)
    with open('.gitignore', 'a') as gitignorefile:
      gitignorefile.write('%s\n' % filename)
    git_add('.gitignore')
  except Exception as e:
    print sys.exc_traceback.tb_lineno
    log_error('Failed to add %s' % filename, e)

def status_local(filename):
  """ Determines if there are local changes made to the file specified in the
      filename parameter.  Assumes filename is the fully qualified name of a got meta file.

      @filename Got meta filename
      @return 1 if The file is unchanged
      @return 0 if the file is changed or not found
  """
  try:
    log_debug('status_local: Parameters %s' % filename)
    actual_filename = get_real_filename(filename)
    log_debug('status_local: Actual %s' % actual_filename)
    if not os.path.exists(actual_filename):
      log_debug('status_local: Did not find file %s' % actual_filename)
      return 0
    sum1 = file_hash(actual_filename)
    sum2 = open(filename).read().rstrip()
    if sum1 != sum2:
      log_debug('status_local: Got hash %i != file hash %i' % (sum1, sum2))
      return 0
    return 1
  except Exception as e:
    log_error('status_local: Failed to status %s' % filename, e)
    return 0

def status_cb(filename):
  """ Retrieves the status of the filename specified.  Invoked from the main
      walker loop.  Assumes the filename passed in is a got meta file.

      @param filename Name of the got meta file to check
  """
  try:
    if not status_local(filename):
      return 'Modified: %s' % actual_filename
  except Exception as e:
    log_error('Failed to status %s' % filename, e)

def log(level, message, exception):
  if None is exception:
    print '%s : %s' % (level, message)
  else:
    print '%s:%s:%s' % (level, message, exception)

def log_error(message, exception = None):
  if 'ERROR' in LOG_LEVELS:
    log('ERROR', message, exception)

def log_warn(message, exception = None):
  if 'WARN' in LOG_LEVELS:
    log('WARN', message, exception)

def log_info(message, exception = None):
  if 'INFO' in LOG_LEVELS:
    log('INFO', message, exception)

def log_debug(message, exception = None):
  if 'DEBUG' in LOG_LEVELS:
    log('DEBUG', message, exception)

def upgrade_cb(new):
  pass

def walker(function, args):
  output = []
  for arg in args:
    log_debug('walker: processing argument %s' % arg)
    if os.path.isfile(arg):
      log_debug('walker: processing file %s' % arg)
      output.append(function(arg))
    else:
      for base, dirs, filenames in os.walk(arg):
        if '.git' in dirs:
          dirs.remove('.git')
        if '.got' in dirs:
          dirs.remove('.got')
        for filename in fnmatch.filter(filenames, '.*.got'):
          log_debug('walker: processing file %s/%s' % (base, filename))
          output.append(function('%s/%s' % (base, filename)))
  return output

def check_initialized():
  if os.path.isfile('.got/storage'):
    init_backing_store()
    return True
  return False

def check_version(version):
  configuration = load_configuration()
  if VERSION != configuration['version']:
    return False
  return True

VERSION = 1

def mkdir_p(path):
  """
  Function to make a directory and all intermediate directories as
  necessary.  The functionality differs from os.makedirs slightly, in
  that this function does *not* raise an error if the directory already
  exists.
  """
  if path is None:
    raise Exception("Path cannot be None")

  if path == '':
    # this can happen if the user did something like call os.path.dirname()
    # on a file without directories.  Since os.makedirs throws an exception
    # in that case, check for it here and allow it.
    return

  try:
    os.makedirs(path)
  except OSError as err:
    if err.errno != errno.EEXIST or not os.path.isdir(path):
      raise

def find_git_path_and_chdir():
  """
  This function is expected to be called at the beginning and goes looking
  for the closest .git subdirectory or file in the filesystem hierarchy.
  We look for the .git subdirectory by first looking in ./.git, then changing
  directory to .. and looking for .git, etc, until we either find a .git
  directory or until we hit / (at which point we raise an error).  At the end
  we have changed directory to the appropriate level, which is similar to how
  git itself operates.  Assuming we succeed, this function returns a relative
  path to the original path we started out in so that subsequent operations
  (that may git add) can do the right thing.
  """
  origpath = os.getcwd()
  curpath = origpath
  while not os.path.exists(os.path.join(curpath, '.git')) and curpath != '/':
    os.chdir("..")
    curpath = os.getcwd()

  if curpath == '/':
    raise Exception, "Could not find git repository"

  # OK, we found the .git directory/file.  Now return the original path
  # relative to that found directory
  return os.path.relpath(origpath, os.path.commonprefix([origpath, os.getcwd()]))

def main(argv):
  # Reseting global "session" variables used for optimizing
  # during invocation.  Useful when unit testing.
  reset()
  num_args = len(argv)

  if num_args < 2:
    usage()
    return 1

  origpath = find_git_path_and_chdir()

  command = argv[1]

  if command == 'init':
    if num_args != 4:
      usage()
      return 1

    remote_type = argv[2]
    if remote_type != 'srr' and remote_type != 'scp':
      usage()
      return 1

    remote = argv[3]
    mkdir_p('.got')
    configuration = { 'remote' : remote , 'remote_type' : remote_type , 'version' : VERSION }
    with open('.got/storage', 'w') as storagefile:
      json.dump(configuration, storagefile)
    git_add('.got/storage')
    ignorefile = open('.gitignore', 'w')
    ignorefile.close()
    git_add('.gitignore')
  elif not check_initialized():
    print 'Got not initialized\n'
    usage()
    return 1
  elif command == 'upgrade':
    upgrade_cb(VERSION)
  elif not check_version(VERSION):
    print 'Version of got repository requires upgrading, run upgrade command'
    usage()
    return 1
  elif command == 'add':
    log_debug('main: Add command %s' % argv[2:])
    walker(add_cb, argv[2:])
  elif command == 'reset':
    walker(reset_cb, argv[2:])
  elif command == 'get':
    walker(get_cb, [get_root()])
  elif command == 'status':
    changes = walker(status_cb, [get_root()])
    print '# Changes',
    for change in changes:
      if None != change:
        print '\n# %s' % change,
    print '\n',
  else:
    usage()

if __name__ == "__main__":
  exit(main(sys.argv))

# vim: set filetype=python :
