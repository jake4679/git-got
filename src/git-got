#!/usr/bin/env python

import sys
import subprocess
import os.path
import os
import hashlib
import json
import fnmatch
import hashlib
import requests
import pycurl
import dulwich.porcelain as porcy

from requests_toolbelt.multipart.encoder import MultipartEncoder

# For SRR support
import httplib
import re

DEFAULT_LOG_LEVELS=['INFO', 'WARN', 'ERROR']

LOG_LEVELS = DEFAULT_LOG_LEVELS

def load_scp(filename, checksum):
  remote = get_remote()
  subprocess.check_call(['scp', '%s/%s.got' % (remote, checksum), filename])

def store_scp(filename, checksum):
  remote = get_remote()
  subprocess.check_call(['scp', filename, '%s/%s.got' % (remote, checksum)])

def store_srr(filename, checksum):
  #m = MultipartEncoder(fields={'parent_id':'70009', 'target_id':'', 'description':'booja', 'file':('empty.dump', open('../empty.dump', 'rb'), 'application/octe/stream')})
  #r = requests.post('http://hq-gnitools.wardrobe.irobot.com/srr/api/add_file', data=m,headers={'Content-Type': m.content_type})
  (server_name, parent_id) = get_location_info_srr()
  local_path = filename
  target_id = ''
  remote_path = '%s' % checksum
  description = 'Got storage for %s/%s @ TBD hashtag' % (get_root(), filename)

  m = MultipartEncoder(fields={
    'parent_id' : parent_id,
    'target_id' : '',
    'description' : description,
    'file' : (checksum, open(filename, 'rb'), 'application/octet-stream')})
  response = requests.post('http://%s/srr/api/add_file' % server_name, data = m, headers = {'Content-Type' : m.content_type})

  if response.status_code != 200:
    raise SRRError("%s: %s" % (response.reason, result))
  new_id_re = re.compile(r' file_id=(\d+)\s*$')
  m = new_id_re.search(response.text)
  if m:
    return int(m.group(1))
  else:
    raise SRRError("Unexpected result from SRR: %s" % result)

def parse_path_srr(path):
  result_re = re.compile('http://(.*)/.*/(\d+)$')
  matches = result_re.match(path)
  return (matches.group(1), matches.group(2))

def get_location_info_srr():
  return parse_path_srr(get_remote())

def get_remote_path_srr(server, checksum):
  response = requests.get('http://%s/srr/api/file_metadata/md5/%s' % (server, checksum))
  return response.json()['url']

def load_srr(filename, checksum):
  (server, parent_id) = get_location_info_srr()

  if status_local(get_got_filename(filename)):
    return

  path = get_remote_path_srr(server, checksum)
  print filename
  print path

  with open(filename, 'wb') as f:
    c = pycurl.Curl()
    c.setopt(c.URL, path)
    c.setopt(c.WRITEDATA, f)
    c.perform()
    c.close()

remote_store_file = store_srr
remote_load_file = load_srr

def init_backing_store():
  configuration = load_configuration()
  if configuration['remote_type'] == 'srr':
    remote_load_file = load_srr
    remote_store_file = store_srr
  else:
    remote_load_file = load_scp
    remote_store_file = store_scp

def usage():
  print 'git got <command> [<args>]'
  print
  print 'The most commonly used git got commands are:'
  print '  init   Initialize the remote to be used with the repository'
  print '    <repository type> <parameters>'
  print '  get    Retrieve all remote files to the local working area'
  print '  add    Add a file to the remote repository'
  print '  status Request the status of a got tracked file'
  print '  reset  Ovewrite a gotted file with the remote copy'

root_valid = False
root_path = ""
repo_valid = False
repo = None

def reset():
  global root_valid
  global root_path
  global repo_valid
  global repo
  root_valid = False
  root_path = ""

def get_repo():
  global repo_valid
  global repo
  if not repo_valid:
    repo = porcy.open_repo(get_root())
    repo_valid = True
  return repo

def git_add(filename):
  porcy.add(get_repo(), filename)

def get_root():
  global root_valid
  global root_path
  if not root_valid:
    root_path = os.getcwd()
    old_root_path = ''
    while not os.path.exists(os.path.join(root_path, '.git')) and root_path is not old_root_path:
      old_root_path = root_path
      root_path = os.path.dirname(root_path)
    root_valid = True
  return root_path

configuration_loaded = False
configuration = []

def file_hash(filename):
  hasher = hashlib.md5()
  infp = open(filename, 'rb')
  try:
    while True:
      data = infp.read(8192)
      if not data:
        break
      hasher.update(data)
  except Exception as e:
    raise
  finally:
    infp.close()
  return hasher.hexdigest()

def load_configuration():
  global configuration_loaded
  global configuration
  if not configuration_loaded:
    storagefp = open('%s/.got/storage' % get_root(), 'r')
    configuration = json.load(storagefp)
    storagefp.close()
    configuration_loaded = True
  return configuration

def get_remote():
  configuration = load_configuration()
  return configuration['remote']

def get_local_got_filename(fully_qualified_filename):
  (base, filename) = os.path.split(fully_qualified_filename)
  return os.path.join(base, '.%s.got' % filename)

def get_got_filename(fully_qualified_filename):
  (root, filename) = os.path.split(fully_qualified_filename)
  return os.path.join(root, '.%s.got' % filename)

def get_real_filename(fully_qualified_filename):
  (root, filename) = os.path.split(fully_qualified_filename)
  return os.path.join(root, filename[1:-4])

def get_cb(filename):
  try:
    real_filename = get_real_filename(filename)
    log_debug('get_cb: Using %s for local file' % real_filename)
    csum = open(filename).read().rstrip()
    remote_load_file(real_filename, csum)
  except Exception as e:
    log_error('Failed to retrieve file %s' % filename, e)

def reset_cb(filename):
  try:
    log_debug('reset_cb: Reseting %s' % filename)
    got_filename = get_local_got_filename(filename)
    log_debug('reset_cb: Using %s for local got file' % got_filename)
    csum = open(got_filename).read().rstrip()
    remote_load_file(filename, csum)
  except Exception as e:
    log_error('Failed to reset %s' % filename, e)

def add_cb(filename):
  try:
    log_debug('add_cb: Adding %s' % filename)
    csum = file_hash(filename)
    remote_store_file(filename, csum)
    got_filename = get_local_got_filename(filename)
    hash_file = open(got_filename, 'w')
    hash_file.write('%s' % csum)
    hash_file.close()
    git_add(got_filename)
    gitignorefile = open('%s/.gitignore' % get_root(), 'a')
    gitignorefile.write('%s\n' % filename)
    gitignorefile.close()
    git_add('%s/.gitignore' % get_root())
  except Exception as e:
    print sys.exc_traceback.tb_lineno
    log_error('Failed to add %s' % filename, e)

def status_local(filename):
  """ Determines if there are local changes made to the file specified in the
      filename parameter.  Assumes filename is the fully qualified name of a got meta file.

      @filename Got meta filename
      @return 1 if The file is unchanged
      @return 0 if the file is changed or not found
  """
  try:
    log_debug('status_local: Parameters %s' % filename)
    actual_filename = get_real_filename(filename)
    log_debug('status_local: Actual %s' % actual_filename)
    if not os.path.exists(actual_filename):
      log_debug('status_local: Did not find file %s' % actual_filename)
      return 0
    sum1 = file_hash(actual_filename)
    sum2 = open(filename).read().rstrip()
    if sum1 != sum2:
      log_debug('status_local: Got hash %i != file hash %i' % (sum1, sum2))
      return 0
    return 1
  except Exception as e:
    log_error('status_local: Failed to status %s' % filename, e)
    return 0

def status_cb(filename):
  """ Retrieves the status of the filename specified.  Invoked from the main
      walker loop.  Assumes the filename passed in is a got meta file.

      @param filename Name of the got meta file to check
  """
  try:
    if not status_local(filename):
      return 'Modified: %s' % actual_filename
  except Exception as e:
    log_error('Failed to status %s' % filename, e)

def start_transaction():
  """ Does nothing for now, placeholder for transaction implementation
  """
  pass

def end_transaction():
  """ Does nothing for now, placeholder for transaction implementation
  """
  pass

def log(level, message, exception):
  if None is exception:
    print '%s : %s' % (level, message)
  else:
    print '%s:%s:%s' % (level, message, exception)

def log_error(message, exception = None):
  if 'ERROR' in LOG_LEVELS:
    log('ERROR', message, exception)

def log_warn(message, exception = None):
  if 'WARN' in LOG_LEVELS:
    log('WARN', message, exception)

def log_info(message, exception = None):
  if 'INFO' in LOG_LEVELS:
    log('INFO', message, exception)

def log_debug(message, exception = None):
  if 'DEBUG' in LOG_LEVELS:
    log('DEBUG', message, exception)

def upgrade_cb(new):
  pass

def walker(function, args):
  output = []
  for arg in args:
    log_debug('walker: processing argument %s' % arg)
    if os.path.isfile(arg):
      log_debug('walker: processing file %s' % arg)
      output.append(function(arg))
    else:
      for base, dirs, filenames in os.walk(arg):
        if '.git' in dirs:
          dirs.remove('.git')
        if '.got' in dirs:
          dirs.remove('.got')
        for filename in fnmatch.filter(filenames, '.*.got'):
          log_debug('walker: processing file %s/%s' % (base, filename))
          output.append(function('%s/%s' % (base, filename)))
  return output

def check_initialized():
  if os.path.isfile('%s/.got/storage' % get_root()):
    init_backing_store()
    return True
  return False

def check_version(version):
  configuration = load_configuration()
  if VERSION != configuration['version']:
    return False
  return True

VERSION = 1

def mkdir_p(path):
    """
    Function to make a directory and all intermediate directories as
    necessary.  The functionality differs from os.makedirs slightly, in
    that this function does *not* raise an error if the directory already
    exists.
    """
    if path is None:
        raise Exception("Path cannot be None")

    if path == '':
        # this can happen if the user did something like call os.path.dirname()
        # on a file without directories.  Since os.makedirs throws an exception
        # in that case, check for it here and allow it.
        return

    try:
        os.makedirs(path)
    except OSError as err:
        if err.errno != errno.EEXIST or not os.path.isdir(path):
            raise

def main(argv):
# Reseting global "session" variables used for optimizing
# during invocation.  Useful when unit testing.
  reset()
  num_args = len(argv)

  if num_args < 2:
    usage()
    return 1

  command = argv[1]

  if command == 'init':
    if num_args != 4:
      usage()
      return 1

    start_transaction()
    remote_type = argv[2]
    if remote_type != 'srr' and remote_type != 'scp':
      usage()
      return 1

    remote = argv[3]
    mkdir_p('%s/.got' % get_root())
    configuration = { 'remote' : remote , 'remote_type' : remote_type , 'version' : VERSION }
    storagefile = open('%s/.got/storage' % get_root(), 'w')
    json.dump(configuration, storagefile)
    storagefile.close()
    git_add('%s/.got/storage' % get_root())
    ignorefile = open('%s/.gitignore' % get_root(), 'w')
    ignorefile.close()
    git_add('%s/.gitignore' % get_root())
    end_transaction()
  elif not check_initialized():
    print 'Got not initialized\n'
    usage()
    return 1
  elif command == 'upgrade':
    upgrade_cb(VERSION)
  elif not check_version(VERSION):
    print 'Version of got repository requires upgrading, run upgrade command'
    usage()
    return 1
  elif command == 'add':
    start_transaction()
    log_debug('main: Add command %s' % argv[2:])
    walker(add_cb, argv[2:])
    end_transaction()
  elif command == 'reset':
    walker(reset_cb, argv[2:])
  elif command == 'get':
    walker(get_cb, [get_root()])
  elif command == 'status':
    changes = walker(status_cb, [get_root()])
    print '# Changes',
    for change in changes:
      if None != change:
        print '\n# %s' % change,
    print '\n',
  else:
    usage()

if __name__ == "__main__":
  exit(main(sys.argv))

# vim: set filetype=python :
